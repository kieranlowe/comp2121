.include "m2560def.inc"

.macro do_lcd_command
	ldi r16, @0
	rcall lcd_command
	rcall lcd_wait
.endmacro

.macro do_lcd_data
	ldi r16, @0
	rcall lcd_data
	rcall lcd_wait
.endmacro

.macro do_lcd_data_alt
	mov r16, @0
	ldi temp2, number_w
	add r16, temp2
	rcall lcd_data
	rcall lcd_wait
.endmacro

;	Clear the floor_register when the parameter given is
;	the address of floor_register
.macro clear_floor_reg
	ldi YL, low(@0)
	ldi YH, high(@0)
	clr temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y+, temp1
	st Y, temp1
.endmacro

.macro clear_timer
	ldi YL, low(@0) ; load the memory address to Y
	ldi YH, high(@0)
	clr temp1
	st Y+, temp1  ; clear the two bytes at @0 in SRAM
	st Y, temp1
.endmacro

.macro clear_sec_timer
	ldi YL, low(@0)
	ldi YH, high(@0)
	clr temp1
	st Y, temp1
.endmacro

.def temp1 = r16
.def temp2 = r17

.def row = r18
.def col = r19
.def rmask = r20
.def cmask = r21

.def pushed = r22
.def dir = r23				; 0 means down, 1 means up
.def curr_floor = r24			; current floor of elevator
.def next_floor = r25			; next floor to move to
.def ele_status = r26			; 0 = closed, 1 = opening doors, 2 = idle open, 3 = closing doors

.equ number_w = 0x30			; binary for 0011, used to write numbers (i.e. 0011 0001 is 1)

.equ PORTLDIR = 0xF0			; 1111 0000
.equ INITCOLMASK = 0xEF			; 1110 1111, right most column
.equ INITROWMASK = 0x01			; 0000 0001, scan from top row
.equ ROWMASK = 0x0F			; 0000 1111, use to obtain input from portL


RESET:
	ldi temp1, low(RAMEND)		; initialise a stack
	out SPL, temp1
	ldi temp1, high(RAMEND)
	out SPH, temp1

;	Setup lcd
	ser temp2
	out DDRF, temp2
	out DDRA, temp2
	clr temp2
	out PORTF, temp2
	out PORTA, temp2

	do_lcd_command 0b00111000 			; 2x5x7
	rcall sleep_5ms
	do_lcd_command 0b00111000 			; 2x5x7
	rcall sleep_1ms
	do_lcd_command 0b00111000 			; 2x5x7
	do_lcd_command 0b00111000 			; 2x5x7
	do_lcd_command 0b00001000 			; display off, cursor off, bar off, blink off
	do_lcd_command 0b00000001 			; clear display
	do_lcd_command 0b00000110 			; increment, no display shift
	do_lcd_command 0b00001100 			; display on, cursor on, no blink

;	Setup timer and enable interrupt (do not activate yet)
	clear tempCounter  				; Initialize the temporary counter to 0
	clear secondCounter  				; Initialize the second counter to 0
	ldi temp1, 0b00000000
	out TCCR0A, temp
	ldi temp1, 0b00000010
	out TCCR0B, temp 				; Prescaling value=8
	ldi temp1, 1<<TOIE0  				; = 128 microseconds
	sts TIMSK0, temp1 				; T/C0 interrupt enable

;;;;;	Experimental!!
;	Setup push button for door closing action
	ldi temp1, (2<<ISC00)
	sts EICRA, temp1
	
	in temp1, EIMSK
	ori temp1, (1 <<INT0)
	out EIMSK, temp1
;;;;;	Experimental!!

	ldi temp1, PORTLDIR				; load temp1 with 1111 0000
	sts DDRL, temp1					; store into pinL

;	Setup some global registers
	ldi pushed, 0
	ldi dir, 1					; default direction is up
	ldi curr_floor, 0				; default floor is ground floor (0)
	ldi ele_status, 0

;	Activate interrupts
	sei

;	Start scanning the keyboard
MAIN:
	ldi cmask, INITCOLMASK			; 1110 1111
	clr col

	;	Print to the lcd.	
	do_lcd_command 0b00000001 		; clear display
	do_lcd_data 'C'
	do_lcd_data 'u'
	do_lcd_data 'r'
	do_lcd_data 'r'
	do_lcd_data 'e'
	do_lcd_data 'n'
	do_lcd_data 't'
	do_lcd_data ' '
	do_lcd_data 'F'
	do_lcd_data 'l'
	do_lcd_data 'o'
	do_lcd_data 'o'
	do_lcd_data 'r'
	do_lcd_data ':'
	do_lcd_data ' '
	do_lcd_data_alt curr_floor
	do_lcd_command 0b11000000 		; set address to second line

	cpi pushed, 1
	breq WAIT
	
;	Scan the columns
	rjmp colloop
	
;	Wait until button isnt being held
WAIT:
	sts PORTL, temp2
	nop
	nop
	lds temp1, PINL				; Obtain value from the keypad
	andi temp1, ROWMASK			; Isolate bottom 4 bits
	cpi temp1, 0xF				; check if row is high (i.e. something being pressed)
	breq READY
	rjmp WAIT
READY:
	ldi pushed, 0
	jmp colloop

colloop:
	cpi col, 4
	breq MAIN					; restart the scan

	sts PORTL, cmask
	ldi temp1, 0xFF				; load temp1 with 1111 1111
	
	jmp delay

;	Debounce
delay:
	dec temp1
	brne delay

	lds temp1, PINL				; read port L
	andi temp1, ROWMASK
	cpi temp1, 0xF				; check if row is high (i.e. nothing pressed)
	breq nextcol

	ldi temp2, 0xFF

delay2:							; wait?
	dec temp2
	nop
	nop
	brne delay2

	lds temp1, PINL
	andi temp1, ROWMASK
	cpi temp1, 0xF
	breq nextcol				; check if row is high (i.e. nothing pressed)

	ldi rmask, INITROWMASK  	; 0000 0001
	clr row

rowloop:
	cpi row, 4					; next col if end of row
	breq nextcol

	mov temp2, temp1
	and temp2, rmask			; check if this row was pressed
	breq convert				; convert if so

	inc row						; next row
	lsl rmask					; shift rmask 0000 0001 -> 0000 0010
	jmp rowloop

nextcol:
	lsl cmask					; 1101 1110
	inc cmask					; 1101 1111
	inc col
	jmp colloop

convert:
;	Do nothing for letters
	cpi col, 3
	breq letters

;	Interpret symbols
	cpi row, 3
	breq symbols

;	Interpret numbers 1-9
	mov temp1, row
	lsl temp1					; number pressed = row*3 + col + 1
	add temp1, row
	add temp1, col
	inc temp1
	mov next_floor, temp1
	rjmp MAIN

;	Do nothing, return to main
letters:
	rjmp MAIN

;	Case for symbols
symbols:
;	Case for asterisk (*)
	cpi col, 0
	breq emergency

;	Case for zero
	cpi col, 1
	breq zero_case

;	Hash symbol, ignore it
	rjmp MAIN

emergency:
	clear_floor_reg floor_register
	ldi ZL, low(floor_register)
	ldi ZH, high(floor_register)
	ldi pushed, 1
	
	ldi temp1, 1
	st Z, temp1
	rjmp MAIN

zero_case:
	ldi temp2, 1
	ldi pushed, 1
	rjmp MAIN

;	Timer that counts seconds
Timer0OVF:
	in temp1, SREG
	push temp1
	push ZH
	push ZL
	push YH
	push YL
	push r25
	push r24

;	Increment the tempCounter, when tempCounter hits 1 second, add 1 second to secondCounter.
;	Clear the tempCounter when it hits 1 second
INCREMENT_TIMER:
;	increment tempCounter
	lds r24, tempCounter
	lds r25, tempCounter+1
	adiw r25:r24, 1

;	Check if it has been one second, if it hasnt,
;	store the tempCounter value
	cpi r24, low(7812)
	ldi temp1, high(7812)
	cpc r25, temp1
	brne NOTSECOND

;	Otherwise it has been a second, reset tempCounter and increment secondCounter
	clear_timer tempCounter
	lds r24, secondCounter
	inc r24
	sts secondCounter, r24
	
	cpi ele_status, 1
	breq opening_doors

	cpi ele_status, 2
	breq idle_state
	
	cpi ele_status, 3
	breq closing_doors

change_floor:
	cpi dir, 1
	breq change_floor_u
	rjmp change_floor_d
change_floor_u:
	inc curr_floor
	clear_sec_timer secondCounter
	rjmp ENDIF
change_floor_d:
	dec curr_floor
	clear_sec_timer secondCounter
	rjmp ENDIF

NOTSECOND:
	sts tempCounter, r24
	sts tempCounter+1, r24
	rjmp ENDIF	

;	If opening doors, check if it has been one second
;	If so, go to idle state (leave door open for three seconds)
opening_doors:
	cpi r24, 1
	breq to_idle
	rjmp ENDIF
	
to_idle:
	ldi ele_status = 2
	clear_sec_timer secondCounter
	rjmp ENDIF

idle_state:
	cpi r24, 3
	breq to_close
	
to_close:
	ldi ele_status = 3
	clear_sec_timer secoundCounter
	rjmp ENDIF

closing_doors:
	cpi r24, 1
	breq door_closed
	rjmp ENDIF
	
door_closed:
	ldi ele_status, 0
	clear_sec_timer secondTimer
	rjmp ENDIF
	
;	return from timer	
ENDIF:
	pop r24 					; Epilogue starts;
	pop r25 					; Restore all conflict registers from the stack.
	pop YL
	pop YH
	pop ZL
	pop ZH
	pop temp1
	out SREG, temp
	reti

;;;;;;	Experimental!!
;	Interrupt triggered by push button
;	Changes elevator door from waiting while open to closing
EXT_INT0:
	push temp1
	in temp1, SREG
	push temp1
	
	cpi ele_status, 2
	breq skip_idle
	
	jmp EXIT_THIS

skip_idle:
	ldi ele_status, 3
	rjmp EXIT_THIS

EXIT_THIS:
	pop temp1
	out SREG, temp1
	pop temp1
	reti
;;;;;;	Experimental!!


.dseg
tempCounter:
	.byte 2
secondCounter:
	.byte 1

.cseg
.org OVF0addr
	jmp Timer0OVF
	
.org INT0addr
	jmp EXT_INT0
